import { NextRequest } from "next/server";
import { streamText } from "ai";
import { Chess } from "chess.js";
import { buildModelPrompt } from "@/lib/prompt";
import { applyChaosMove, parseUciMove } from "@/lib/chess-utils";
import { MatchRequest, MatchMode, MatchResult, MatchStreamEvent } from "@/lib/types";

export const maxDuration = 60;
export const dynamic = "force-dynamic";

const encoder = new TextEncoder();
const MAX_PLY = 400;
const gatewayKey =
  process.env.AI_GATEWAY_API_KEY ||
  process.env.AI_GATEWAY_TOKEN ||
  process.env.OPENAI_API_KEY;

if (!gatewayKey) {
  throw new Error(
    "Missing AI key. Set AI_GATEWAY_API_KEY (preferred) or AI_GATEWAY_TOKEN or OPENAI_API_KEY."
  );
}

async function fetchMove(model: string, prompt: string, timeoutMs = 20000) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);

  try {
    console.log(`[fetchMove] Calling model: ${model}`);
    console.log(`[fetchMove] Prompt:\n${prompt}`);
    const { textStream } = await streamText({
      model,
      prompt,
      temperature: 0.7,
      abortSignal: controller.signal
    });

    let text = "";
    for await (const chunk of textStream) {
      text += chunk;
    }
    const trimmed = text.trim();
    console.log(`[fetchMove] Model ${model} returned: "${trimmed}"`);
    return trimmed;
  } finally {
    clearTimeout(timer);
  }
}

function send(controller: ReadableStreamDefaultController, event: MatchStreamEvent) {
  controller.enqueue(encoder.encode(JSON.stringify(event) + "\n"));
}

function buildResult(
  winner: MatchResult["winner"],
  reason: MatchResult["reason"],
  moves: string[],
  illegalCounts: MatchResult["illegalCounts"],
  chess: Chess
): MatchResult {
  const pgn = chess.history().length > 0 ? chess.pgn({ newline: "\n" }) : moves.join(" ");
  return {
    winner,
    reason,
    moves,
    pgn,
    illegalCounts,
    finalFen: chess.fen()
  };
}

function resultFromDraw(reason: MatchResult["reason"], moves: string[], illegalCounts: MatchResult["illegalCounts"], chess: Chess) {
  return buildResult("draw", reason, moves, illegalCounts, chess);
}

export async function POST(req: NextRequest) {
  if (!gatewayKey) {
    return new Response(
      "Server missing AI key. Set AI_GATEWAY_API_KEY (preferred) or AI_GATEWAY_TOKEN or OPENAI_API_KEY and restart.",
      { status: 500 }
    );
  }

  let body: MatchRequest;
  try {
    body = await req.json();
  } catch {
    return new Response("Invalid JSON", { status: 400 });
  }

  const { whiteModel, blackModel, mode } = body;
  if (!whiteModel || !blackModel) {
    return new Response("whiteModel and blackModel are required", { status: 400 });
  }

  const stream = new ReadableStream({
    async start(controller) {
      let fen = new Chess().fen();
      let chess = new Chess(fen);
      let fullmove = 1;
      const illegalCounts = { white: 0, black: 0 };
      const moves: string[] = [];

      send(controller, { type: "status", message: "Match starting" });

      for (let ply = 0; ply < MAX_PLY; ply++) {
        const activeColor = chess.turn() === "w" ? "white" : "black";
        const activeModel = activeColor === "white" ? whiteModel : blackModel;
        const prompt = buildModelPrompt({
          fen,
          history: moves,
          activeColor,
          mode: mode as MatchMode
        });

        let rawMove = "";
        const moveStartTime = Date.now();
        try {
          rawMove = await fetchMove(activeModel, prompt);
        } catch (err: any) {
          console.error("Model call failed:", err);
          const winner = activeColor === "white" ? "black" : "white";
          const message =
            err instanceof Error ? err.message : "Model call failed or timed out";
          const result = buildResult(winner, "timeout", moves, illegalCounts, chess);
          send(controller, { type: "status", message: `${activeColor} error: ${message}` });
          send(controller, { type: "end", result });
          controller.close();
          return;
        }
        const moveTime = Date.now() - moveStartTime;

        const cleaned = rawMove.trim().toLowerCase();
        if (cleaned === "resign") {
          const winner = activeColor === "white" ? "black" : "white";
          const result = buildResult(winner, "resignation", moves, illegalCounts, chess);
          send(controller, {
            type: "move",
            move: "resign",
            fen,
            ply,
            activeColor,
            illegalCounts,
            timestamp: moveTime
          });
          send(controller, { type: "end", result });
          controller.close();
          return;
        }

        const parsed = parseUciMove(cleaned);
        const opponent = activeColor === "white" ? "black" : "white";
        console.log(`[Match] Raw: "${rawMove}" -> Cleaned: "${cleaned}" -> Parsed: ${JSON.stringify(parsed)}`);

        if (!parsed) {
          console.log(`[Match] Failed to parse move for ${activeColor}: "${cleaned}"`);
          illegalCounts[activeColor] += 1;

          // Send invalid move to move log
          send(controller, {
            type: "move",
            move: cleaned || "(empty)",
            fen,
            san: `❌ ${cleaned || "empty"}`,
            ply,
            activeColor,
            illegalCounts,
            note: "Invalid move - failed to parse",
            timestamp: moveTime
          });

          send(controller, {
            type: "status",
            message: `${activeColor} returned an invalid move (${cleaned || "empty"})`
          });

          if (mode === "strict" && illegalCounts[activeColor] >= 5) {
            const result = buildResult(opponent, "illegal", moves, illegalCounts, chess);
            send(controller, { type: "end", result });
            controller.close();
            return;
          }

          continue;
        }

        let moveResult = null;
        try {
          moveResult = chess.move(parsed);
        } catch (err: any) {
          console.log(`[Match] Chess.js threw error for move ${JSON.stringify(parsed)}: ${err.message}`);
          moveResult = null;
        }

        if (!moveResult) {
          illegalCounts[activeColor] += 1;
          console.log(`[Match] Chess.js rejected move ${JSON.stringify(parsed)} for ${activeColor}`);

          // Send illegal move to move log
          send(controller, {
            type: "move",
            move: cleaned,
            fen,
            san: `❌ ${cleaned}`,
            ply,
            activeColor,
            illegalCounts,
            note: "Illegal move - violates chess rules",
            timestamp: moveTime
          });

          if (mode === "chaos") {
            const chaos = applyChaosMove(fen, parsed, chess.turn(), fullmove);
            fen = chaos.fen;
            chess = new Chess(fen);
            fullmove = parseInt(fen.split(" ")[5], 10) || fullmove;
            moves.push(chaos.san);

            send(controller, {
              type: "move",
              move: chaos.san,
              fen,
              san: chaos.san,
              ply,
              activeColor,
              illegalCounts,
              note: "Chaos move executed despite illegality",
              timestamp: moveTime
            });
          } else {
            send(controller, {
              type: "status",
              message: `${activeColor} played illegal move ${cleaned} (${illegalCounts[activeColor]} strikes)`
            });
          }

          if (mode === "strict" && illegalCounts[activeColor] >= 5) {
            const result = buildResult(opponent, "illegal", moves, illegalCounts, chess);
            send(controller, { type: "end", result });
            controller.close();
            return;
          }

          continue;
        }

        fen = chess.fen();
        fullmove = parseInt(fen.split(" ")[5], 10) || fullmove;
        illegalCounts[activeColor] = 0;
        const moveUci = `${moveResult.from}${moveResult.to}${moveResult.promotion ?? ""}`;
        moves.push(moveUci);

        send(controller, {
          type: "move",
          move: moveUci,
          fen,
          san: moveResult.san,
          ply,
          activeColor,
          illegalCounts,
          timestamp: moveTime
        });

        if (chess.isCheckmate()) {
          const result = buildResult(activeColor, "checkmate", moves, illegalCounts, chess);
          send(controller, { type: "end", result });
          controller.close();
          return;
        }

        if (chess.isStalemate()) {
          const result = resultFromDraw("stalemate", moves, illegalCounts, chess);
          send(controller, { type: "end", result });
          controller.close();
          return;
        }

        if (chess.isThreefoldRepetition()) {
          const result = resultFromDraw("threefold", moves, illegalCounts, chess);
          send(controller, { type: "end", result });
          controller.close();
          return;
        }

        if (chess.isInsufficientMaterial()) {
          const result = resultFromDraw("insufficient", moves, illegalCounts, chess);
          send(controller, { type: "end", result });
          controller.close();
          return;
        }

        if (chess.isDraw()) {
          const result = resultFromDraw("fifty-move", moves, illegalCounts, chess);
          send(controller, { type: "end", result });
          controller.close();
          return;
        }
      }

      const result = resultFromDraw("max-move", moves, illegalCounts, chess);
      send(controller, { type: "end", result });
      controller.close();
    }
  });

  return new Response(stream, {
    headers: {
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive",
      "Content-Type": "text/event-stream"
    }
  });
}

